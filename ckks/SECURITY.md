# Security of Approximate-Numbers Homomorphic Encryption

Homomorphic encryption schemes are malleable schemes by definition and are therefore not secure against chosen ciphertext attacks (CPA security). They instead rely on the more relaxed security of being secure against chosen plaintext attacks (CPA security).  

Classified as an _approximate decryption_ scheme, the CKKS scheme is secure as long as the plain decryption is only revealed to entities with knowledge of the secret-key. This is because, given a ciphertext (_-as + m + e_, _a_), the decryption will output a plaintext _m+e_ and using this plaintext, [Li and Micciancio](https://eprint.iacr.org/2020/1533) show that one recover the secret-key with ((_-as + m + e_) - (_m + e_)) * _a^-1 = asa^-1 = s_ (the probability of _a_ being invertible is overwhelming, and if _a_ is not invertible one only require a few more samples).

This attack demonstrates that, when using an approximate homomorphic encryption schemes, the usual CPA security is not sufficient depending on the application setting. Indeed, while a lot of applications do not require to share the result with external parties, the ones that do must take the appropriate steps to ensure that no key-dependent material leaked. A homomorphic encryption scheme that provides such functionality and that can be secure when releasing decrypted plaintext to external parties is defined to be CPA+ secure.

# CPA+ Security for CKKS
Lattigo implements tools to mitigate _Li and Micciancio_'s attack. In particular, the decoding step of the CKKS (and its real number variant R-CKKS) allows the user add a key-independent error **_e_** of standard deviation **_σ_** to the decrypted plaintext before decoding.

If at any point of an application decrypted material is be shared with external parties, then the user must ensure that each shared plaintext is first _sanitized_ before being shared. To do so, the user must use the **DecodePublic** method instead of the usual **Decode**. **DecodePublic** takes as additional input **_σ_**, and will sample a key-independant error **_e_**, with standard deviation **_σ_**, that will be added to the plaintext before the decoding.

Estimating **_σ_** must be done carefully and we suggest the following iterative process to do so :
 1. Given a circuit **_C_** taking as inputs vectors **_ω_** of size **_n_** following a distribution **_χ_** and a security parameter **_λ_**, select the appropriate parameters allowing the homomorphic evaluation of **_d(ω)_**, denominated by **_H(d(ω))_**, which includes the encoding, encryption, evaluation, decryption and decoding.
 2. Sample inputs vectors **_ω_** from the distribution **_χ_** and compute the standard deviation **_σ_** in the time domain (coefficient domain) of **_e = d(ω) - H(d(ω))_**. This can be done using the encoder method **GetErrSTDTimeDom(_d(ω)_, _H(d(ω))_, _Δ_)**, where **_Δ_** is the scale of the plaintext after the decryption. The user should make sure that **d()** is identical **H(d())**, in other words, if **H(d())** uses polynomial approximations, then **d()** should use them too, instead of using the actual exact function. This will ensure that **_e_**, and therefore **_σ_**, are as close as possible to the actual underlying scheme error, and not influenced by approximation errors.
 3. Use the encoder method **DecodePublic** with the parameter **_σ_** to decode plaintexts that will be published. **DecodePublic** will add an error **_e_** of standard deviation **_σ_** bounded by **B = _σ • (2π)^0.5_**. The precision loss, compared to a private decoding, should be less than half a bit on average.
